#coding=utf-8
###### 问题性质：二分类问题
###### 研究对象：三元组--（user_id,item_id,daynum）
###### 特征向量：1）考察日前一天各种行为<浏览，收藏，加购物车，成交>的统计量
#                2）购物狂系数：一个人在31天内的总成交量
#                3）畅销品系数：一件商品在31天内的总成交量
#       标签：   是否成交(0,1)

##### 29日为训练日，30日为线下测试，31日为在线测试  #######
##### 分别取29，30，31的候选对象，选取基准是前一天产生过行为的uid ###

import numpy as np
import pandas as pd
import pickle
import math
import logging
import datetime
from logging import info
logging.basicConfig(level = logging.INFO)


### 核心函数：
def feature_label(X,Y,uid_set):
    '''
    特征_标签函数：负责为每一个候选对象拼接特征向量，以及打标签
    '''
    id = 0
    for uid in uid_set:
        last_uid = (uid[0],uid[1],uid[2] - 1)    # 这个步骤很容易漏，有个逻辑一定要理清：29号的候选对象-->特征向量由28号决定，标签才由29号决定
                                            # 所以这里一定要将time-1，构造last_uid,为构造特征向量做准备
        ## 特征向量集
        # 前4个特征：针对浏览，收藏，加购物车，购买4种行为进行统计，并设置不同的权重
        # [我的思路，有待考察] 越是重要的特征，越是要把量给压缩掉。少量影响全局，才能获得更大的权重系数

        # 后2个特征：
        #           1）特征5：一个人在31天内的全部成交次数，我称之为：购买狂系数
        #           2）特征6：一件商品在31天内被成交的次数，我称之为：畅销货系数
        # 这2个特征统计难度较大，需要借助下面的“巨型数据结构”，而且运算时间很长

        # 判断候选对象是否在feature或label的映射表中：
        for idx in range(6):
            if idx == 0:
                X[id][idx] = math.log1p(feature_dict[idx][last_uid] if last_uid in feature_dict[idx] else 0)
            elif idx == 1:
                X[id][idx] = math.log1p(feature_dict[idx][last_uid] if last_uid in feature_dict[idx] else 0) / 3
            elif idx == 2:
                X[id][idx] = math.log1p(feature_dict[idx][last_uid] if last_uid in feature_dict[idx] else 0) / 5
            elif idx == 3:
                X[id][idx] = math.log1p(feature_dict[idx][last_uid] if last_uid in feature_dict[idx] else 0) * 3
            elif idx == 4:
                cnt_user_buy = 0
                for idx_daynum in range(31):
                    if uid[0] in useritem_allday_buycnt[idx_daynum][0]:
                        print("购物狂")
                        cnt_user_buy += useritem_allday_buycnt[idx_daynum][0][uid[0]]
                    else:
                        continue
                X[id][idx] = math.log1p(cnt_user_buy)
            elif idx == 5:
                cnt_item_buy = 0
                for idx_daynum in range(31):
                    if uid[1] in useritem_allday_buycnt[idx_daynum][1]:
                        print("畅销货")
                        cnt_item_buy += useritem_allday_buycnt[idx_daynum][1][uid[1]]
                    else:
                        continue
                X[id][idx] = math.log1p(cnt_item_buy)
        # 真。打标签
        Y[id] = 1 if uid in uid_buy else 0 # 【铺垫】对uid_buy的技巧处理，让这一步打标签的逻辑非常简洁
        id += 1

### 1.读入全部数据
data_all = pd.read_csv("data/tianchi_fresh_comp_train_user.csv")

data_all = data_all.sample(n = 20000)
# # 天数_月日的映射表
# day_map = {"30":[12,18],"29":[12,17],"28":[12,16]}
#
# # 函数：通过天数筛选对应数据
# # 因为初试数据的time格式为：年-月-日-时辰，而不是天数
# def filter_data_by_day(data_original,day):
#     bool_list = []
#     day_map_value = day_map[day]
#     for time in data_original["time"]:   # [注]time的格式是:年-月-日-时辰
#         date = time.split()[0]
#         month = date.split("-")[1]
#         day = date.split("-")[2]
#         if month == str(day_map_value[0]) and int(day) >= day_map_value[1]:
#             bool_list.append(True)
#         else:
#             bool_list.append(False)
#     return data_original[bool_list]        # 布尔索引
#
#
# ### 2.将28-30天的数据筛选出来
# data_28 = filter_data_by_day(data_all,"28")

# Current_dt_csv = Current_dt_csv_temp.date().strftime('%Y-%m-%d')
# 日期_天数的映射表
#[注]天数统一为int类型


first_day  = datetime.datetime.strptime('2014-12-18','%Y-%m-%d')

data_all_time = data_all["time"]

data_all_date = data_all_time.map(lambda time:time.split()[0])

data_all["time"] = data_all_date.map(lambda data_all_date:
                                     (first_day - datetime.datetime.strptime(data_all_date,'%Y-%m-%d')).days)

data_all.to_csv("0-30data_daynum_int_version.csv")  # 持久化

data_28 = data_all[data_all['time'>= 28]]




# useritem_allday_buycnt = []
# for idx in range(31):
#     # l_day是以天数为基准的列表
#     # 两张映射表--> 一张为：人_购买统计,
#     #            另一张为：货_被购买投机
#     l_day = [{} for i in range(2)]
#     data = data_all[data_all["time"] == idx]   # 布尔索引：以daytime为基准
#     print(data)
#     for dt_idx in data.index:
#         type = int(data["behavior_type"][dt_idx]) - 1
#         if type == 3:    # 说明是购买行为
#             print("buy")
#             user = data["user_id"][dt_idx]
#             item = data["item_id"][dt_idx]
#             if user in l_day[0]:
#                 l_day[0][user] += 1
#             else:
#                 l_day[0][user] = 1
#             if item in l_day[1]:
#                 l_day[1][item] += 1
#             else:
#                 l_day[1][item] = 1
#         else:           # 说明不是购买行为，直接跳过，简化运算
#             continue
#     useritem_allday_buycnt.append(l_day)
